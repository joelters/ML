theme_minimal()
# sign accuracy
n1 = n-1
sgnacc <- sapply(1:n1, function(uu){
uu1 <- uu + 1
aaa = (fvs[uu] > fvs[uu1:n]) - (fvs[uu] < fvs[uu1:n]) !=
(fvs0[uu] > fvs0[uu1:n]) - (fvs0[uu] < fvs0[uu1:n])
})
mean(unlist(sgnacc))
rm(list = ls())
library(devtools)
document()
set.seed(1)
n = 5000
X1 = rnorm(n)
X2 = rnorm(n)
eps = rnorm(n)
Y = 1 + X1 + X2 + eps
X = data.frame(X1 = X1, X2 = X2)
ML = c("RF")
mcv <- MLtuning(X,Y,ML = ML, mtry = c(1,2), rf.depth.grid = c(1,2,4), rf.cf.ntree.grid = c(300, 500, 800), var_penalization = 0.9, verbose = TRUE)
mcv$results_best
fvs = as.numeric(mcv$best.fvs.across.ml)
var(fvs)
# Load required library
library(ggplot2)
library(dplyr)
fvs0 = 1 + X1 + X2
dfpl = data.frame(fvs0 = fvs0, fvs = fvs)
# Order the data by fvs0
dfpl <- dfpl %>%
arrange(fvs0) %>%
mutate(index = row_number())
# Create the ggplot
ggplot(dfpl, aes(x = index)) +
geom_line(aes(y = fvs0, color = "fvs0"), size = 1) +
geom_line(aes(y = fvs, color = "fvs"), size = 1) +
labs(title = "Ordered Data Plot",
x = "Index",
y = "Values",
color = "Legend") +
theme_minimal()
# sign accuracy
n1 = n-1
sgnacc <- sapply(1:n1, function(uu){
uu1 <- uu + 1
aaa = (fvs[uu] > fvs[uu1:n]) - (fvs[uu] < fvs[uu1:n]) !=
(fvs0[uu] > fvs0[uu1:n]) - (fvs0[uu] < fvs0[uu1:n])
})
mean(unlist(sgnacc))
rm(list = ls())
library(devtools)
document()
set.seed(1)
n = 5000
X1 = rnorm(n)
X2 = rnorm(n)
eps = rnorm(n)
Y = 1 + X1 + X2 + eps
X = data.frame(X1 = X1, X2 = X2)
ML = c("RF")
mcv <- MLtuning(X,Y,ML = ML, mtry = c(1,2), rf.depth.grid = c(1,2,4), rf.cf.ntree.grid = c(300, 500, 800), var_penalization = 0.1, verbose = TRUE)
mcv$results_best
fvs = as.numeric(mcv$best.fvs.across.ml)
var(fvs)
# Load required library
library(ggplot2)
library(dplyr)
fvs0 = 1 + X1 + X2
dfpl = data.frame(fvs0 = fvs0, fvs = fvs)
# Order the data by fvs0
dfpl <- dfpl %>%
arrange(fvs0) %>%
mutate(index = row_number())
# Create the ggplot
ggplot(dfpl, aes(x = index)) +
geom_line(aes(y = fvs0, color = "fvs0"), size = 1) +
geom_line(aes(y = fvs, color = "fvs"), size = 1) +
labs(title = "Ordered Data Plot",
x = "Index",
y = "Values",
color = "Legend") +
theme_minimal()
# sign accuracy
n1 = n-1
sgnacc <- sapply(1:n1, function(uu){
uu1 <- uu + 1
aaa = (fvs[uu] > fvs[uu1:n]) - (fvs[uu] < fvs[uu1:n]) !=
(fvs0[uu] > fvs0[uu1:n]) - (fvs0[uu] < fvs0[uu1:n])
})
mean(unlist(sgnacc))
mcv$results_best$RF$rmse
mcv$best.across.ml$rmse
mcv$results_best[[1]]
library(party)
?cforest
rm(list = ls())
library(devtools)
document()
set.seed(1)
n = 5000
X1 = rnorm(n)
X2 = rnorm(n)
eps = rnorm(n)
Y = 1 + X1 + X2 + eps
X = data.frame(X1 = X1, X2 = X2)
dff = data.frame(Y = Y, X)
dta = dff
weights = NULL
model <- party::cforest(Y ~ .,
data = dta,
controls = party::cforest_unbiased(mtry = mtry,
ntree = rf.cf.ntree),
weights = weights)
mtry = 2
ntree = 50
model <- party::cforest(Y ~ .,
data = dta,
controls = party::cforest_unbiased(mtry = mtry,
ntree = rf.cf.ntree),
weights = weights)
rf.cf.ntree = 50
model <- party::cforest(Y ~ .,
data = dta,
controls = party::cforest_unbiased(mtry = mtry,
ntree = rf.cf.ntree),
weights = weights)
model <- party::cforest(Y ~ .,
data = dta,
controls = party::cforest_unbiased(mtry = mtry,
ntree = rf.cf.ntree,
maxdepth = 2),
weights = weights)
model <- party::cforest(Y ~ .,
data = dta,
controls = party::cforest_unbiased(mtry = mtry,
ntree = rf.cf.ntree,
maxdepth = 0),
weights = weights)
model <- party::cforest(Y ~ .,
data = dta,
controls = party::cforest_unbiased(mtry = mtry,
ntree = rf.cf.ntree,
maxdepth = -3),
weights = weights)
model <- party::cforest(Y ~ .,
data = dta,
controls = party::cforest_unbiased(mtry = mtry,
ntree = rf.cf.ntree,
maxdepth = 1),
weights = weights)
model
model <- party::cforest(Y ~ .,
data = dta,
controls = party::cforest_unbiased(mtry = mtry,
ntree = rf.cf.ntree,
maxdepth = 1),
weights = weights)
model <- party::cforest(Y ~ .,
data = dta,
controls = party::cforest_unbiased(mtry = mtry,
ntree = rf.cf.ntree,
maxdepth = 6),
weights = weights)
args(party::cforest_control)
args(party::cforest_unbiased)
party::cforest_unbiased
party::cforest_control
formals(party::cforest_control)
library(party)
# Generate a simple tree with depth constraint
fit <- cforest(Species ~ .,
data = iris,
controls = cforest_control(maxdepth = 1, ntree = 1))
# Check the structure
print(fit)
plot(fit@ensemble[[1]])  # Plot the first tree in the forest
party::plot.party(fit@ensemble[[1]])
plot(fit@ensemble[[1]], type = "simple")
tree <- as.party(fit@ensemble[[1]])
library(party)
library(partykit)
install.packages("partykit")
library(party)
library(partykit)
# Generate a simple tree with depth constraint
fit <- cforest(Species ~ .,
data = iris,
controls = cforest_control(maxdepth = 1, ntree = 1))
# Generate a simple tree with depth constraint
fit <- party::cforest(Species ~ .,
data = iris,
controls = cforest_control(maxdepth = 1, ntree = 1))
library(party)
library(partykit)
# Generate a simple tree with depth constraint
fit <- party::cforest(Species ~ .,
data = iris,
controls = cforest_control(maxdepth = 1, ntree = 1))
# Generate a simple tree with depth constraint
fit <- party::cforest(Species ~ .,
data = iris,
controls = cforest_control(maxdepth = 1, ntree = 1, mtry = 2))
# Check the structure
print(fit)
tree <- as.party(fit@ensemble[[1]])
tree <- partykit::as.party(fit@ensemble[[1]])
tree <- partykit::tree <- as.constparty(fit@ensemble[[1]])
install.packages("party")
library(party)
library(partykit)
# Generate a simple tree with depth constraint
fit <- party::cforest(Species ~ .,
data = iris,
controls = cforest_control(maxdepth = 1, ntree = 1, mtry = 2))
# Check the structure
print(fit)
tree <- partykit::tree <- as.constparty(fit@ensemble[[1]])
get_depth_from_list_tree <- function(node) {
# Base case: no children means a leaf
if (is.null(node$left) && is.null(node$right)) return(1)
# Recursively compute depth of each branch
left_depth <- if (!is.null(node$left)) get_depth_from_list_tree(node$left) else 0
right_depth <- if (!is.null(node$right)) get_depth_from_list_tree(node$right) else 0
return(1 + max(left_depth, right_depth))
}
# Apply to one of your trees
get_depth_from_list_tree(fit@ensemble[[1]]@tree)
get_depth_from_raw_tree <- function(node) {
if (is.null(node$left) && is.null(node$right)) return(1)
left_depth <- if (!is.null(node$left)) get_depth_from_raw_tree(node$left) else 0
right_depth <- if (!is.null(node$right)) get_depth_from_raw_tree(node$right) else 0
return(1 + max(left_depth, right_depth))
}
# Apply to one of your trees
get_depth_from_raw_tree(fit$ensemble[[1]])
tree <- fit@ensemble[[1]]  # This is a plain list tree
View(tree)
get_depth_from_raw_tree <- function(node) {
if (is.null(node$left) && is.null(node$right)) return(1)
left_depth <- if (!is.null(node$left)) get_depth_from_raw_tree(node$left) else 0
right_depth <- if (!is.null(node$right)) get_depth_from_raw_tree(node$right) else 0
return(1 + max(left_depth, right_depth))
}
# Apply to the first tree
get_depth_from_raw_tree(tree)
library(party)
library(partykit)
# Generate a simple tree with depth constraint
fit <- party::cforest(Species ~ .,
data = iris,
controls = cforest_control(maxdepth = 5, ntree = 1, mtry = 2))
# Check the structure
print(fit)
tree <- partykit::tree <- as.constparty(fit@ensemble[[1]])
library(party)
library(partykit)
# Generate a simple tree with depth constraint
fit <- party::cforest(Species ~ .,
data = iris,
controls = cforest_control(maxdepth = 5, ntree = 1, mtry = 2))
# Check the structure
print(fit)
tree <- fit@ensemble[[1]]  # This is a plain list tree
get_depth_from_raw_tree <- function(node) {
if (is.null(node$left) && is.null(node$right)) return(1)
left_depth <- if (!is.null(node$left)) get_depth_from_raw_tree(node$left) else 0
right_depth <- if (!is.null(node$right)) get_depth_from_raw_tree(node$right) else 0
return(1 + max(left_depth, right_depth))
}
# Apply to the first tree
get_depth_from_raw_tree(tree)
library(party)
library(partykit)
# Generate a simple tree with depth constraint
fit <- party::cforest(Species ~ .,
data = iris,
controls = cforest_control(maxdepth = 5, ntree = 50, mtry = 2))
# Check the structure
print(fit)
tree <- fit@ensemble[[1]]  # This is a plain list tree
get_depth_from_raw_tree <- function(node) {
if (is.null(node$left) && is.null(node$right)) return(1)
left_depth <- if (!is.null(node$left)) get_depth_from_raw_tree(node$left) else 0
right_depth <- if (!is.null(node$right)) get_depth_from_raw_tree(node$right) else 0
return(1 + max(left_depth, right_depth))
}
# Apply to the first tree
get_depth_from_raw_tree(tree)
depths <- sapply(fit@ensemble, get_depth_from_raw_tree)
summary(depths)
library(party)
library(partykit)
# Generate a simple tree with depth constraint
fit <- party::cforest(Species ~ .,
data = iris,
controls = cforest_control(minbucket = 5, ntree = 50, mtry = 2))
# Check the structure
print(fit)
tree <- fit@ensemble[[1]]  # This is a plain list tree
get_depth_from_raw_tree <- function(node) {
if (is.null(node$left) && is.null(node$right)) return(1)
left_depth <- if (!is.null(node$left)) get_depth_from_raw_tree(node$left) else 0
right_depth <- if (!is.null(node$right)) get_depth_from_raw_tree(node$right) else 0
return(1 + max(left_depth, right_depth))
}
# Apply to the first tree
get_depth_from_raw_tree(tree)
depths <- sapply(fit@ensemble, get_depth_from_raw_tree)
summary(depths)
library(party)
library(partykit)
# Generate a simple tree with depth constraint
fit <- party::cforest(Species ~ .,
data = iris,
controls = cforest_control(minbucket = 1, ntree = 50, mtry = 2))
# Check the structure
print(fit)
tree <- fit@ensemble[[1]]  # This is a plain list tree
get_depth_from_raw_tree <- function(node) {
if (is.null(node$left) && is.null(node$right)) return(1)
left_depth <- if (!is.null(node$left)) get_depth_from_raw_tree(node$left) else 0
right_depth <- if (!is.null(node$right)) get_depth_from_raw_tree(node$right) else 0
return(1 + max(left_depth, right_depth))
}
# Apply to the first tree
get_depth_from_raw_tree(tree)
depths <- sapply(fit@ensemble, get_depth_from_raw_tree)
summary(depths)
library(party)
library(partykit)
# Generate a simple tree with depth constraint
fit <- party::cforest(Species ~ .,
data = iris,
controls = cforest_control(minbucket = 1, ntree = 50, mtry = 2,
mincriterion = 0))
# Check the structure
print(fit)
tree <- fit@ensemble[[1]]  # This is a plain list tree
get_depth_from_raw_tree <- function(node) {
if (is.null(node$left) && is.null(node$right)) return(1)
left_depth <- if (!is.null(node$left)) get_depth_from_raw_tree(node$left) else 0
right_depth <- if (!is.null(node$right)) get_depth_from_raw_tree(node$right) else 0
return(1 + max(left_depth, right_depth))
}
# Apply to the first tree
get_depth_from_raw_tree(tree)
depths <- sapply(fit@ensemble, get_depth_from_raw_tree)
summary(depths)
ct <- ctree(Species ~ ., data = iris,
controls = ctree_control(minbucket = 1, mincriterion = 0))
# Let's inspect this tree visually
plot(ct)
ct <- ctree(Species ~ ., data = iris,
controls = ctree_control(minbucket = 1, mincriterion = 0.01))
library(party)
library(partykit)
# Generate a simple tree with depth constraint
fit <- party::cforest(Species ~ .,
data = iris,
controls = cforest_control(minbucket = 1, ntree = 50, mtry = 2,
mincriterion = 0))
# Check the structure
print(fit)
# Convert a tree from the ensemble to a plottable form
tree <- partykit::as.constparty(fit@ensemble[[1]])
# Build a single decision tree (not a forest)
tree_model <- ctree(Species ~ ., data = iris,
controls = ctree_control(minbucket = 1, mincriterion = 0))
library(party)
library(partykit)
# Generate a simple tree with depth constraint
fit <- party::cforest(Species ~ .,
data = iris,
controls = cforest_control(minbucket = 1, ntree = 50, mtry = 2,
mincriterion = 0))
# Check the structure
print(fit)
# Convert a tree from the ensemble to a plottable form
tree <- partykit::as.constparty(fit@ensemble[[1]])
# Build a single decision tree (not a forest)
tree_model <- ctree(Species ~ ., data = iris,
control = ctree_control(minbucket = 1, mincriterion = 0))
# Plot it
plot(tree_model)
# Build a single decision tree (not a forest)
tree_model <- ctree(Species ~ ., data = iris,
control = ctree_control(minbucket = 6, mincriterion = 0))
# Plot it
plot(tree_model)
# Build a single decision tree (not a forest)
tree_model <- ctree(Species ~ ., data = iris,
control = ctree_control(minbucket = 50, mincriterion = 0))
# Plot it
plot(tree_model)
?partykit::cforest
Inf
rm(list = ls())
library(devtools)
document()
set.seed(1)
n = 5000
X1 = rnorm(n)
X2 = rnorm(n)
eps = rnorm(n)
Y = 1 + X1 + X2 + eps
X = data.frame(X1 = X1, X2 = X2)
ML = c("CIF")
m = modest(X,Y,ML=ML,cf.depth = 1, mtry = 2, rf.cf.ntree = 5)
debug(modest)
m = modest(X,Y,ML=ML,cf.depth = 1, mtry = 2, rf.cf.ntree = 5)
rm(list = ls())
library(devtools)
document()
set.seed(1)
n = 5000
X1 = rnorm(n)
X2 = rnorm(n)
eps = rnorm(n)
Y = 1 + X1 + X2 + eps
X = data.frame(X1 = X1, X2 = X2)
ML = c("CIF")
m = modest(X,Y,ML=ML,cf.depth = 1, mtry = 2, rf.cf.ntree = 5)
rm(list = ls())
library(devtools)
document()
set.seed(1)
n = 5000
X1 = rnorm(n)
X2 = rnorm(n)
eps = rnorm(n)
Y = 1 + X1 + X2 + eps
X = data.frame(X1 = X1, X2 = X2)
ML = c("CIF")
m = modest(X,Y,ML=ML, cf.depth = 1, mtry = 2, rf.cf.ntree = 5)
m = modest(X,Y,ML=ML, cf.depth = 1, mtry = 2, rf.cf.ntree = 500)
m = modest(X,Y,ML=ML, cf.depth = 1, mtry = 2, rf.cf.ntree = 5000)
m = modest(X,Y,ML=ML, cf.depth = 1, mtry = 2, rf.cf.ntree = 500)
m = modest(X,Y,ML=ML, cf.depth = 6, mtry = 2, rf.cf.ntree = 500)
Inf == Inf
`%notin%` <- Negate(`%in%`)
Inf %notin% c(1,2,3)
Inf %notin% c(1,2,3, Inf)
rm(list = ls())
library(devtools)
document()
set.seed(1)
n = 5000
X1 = rnorm(n)
X2 = rnorm(n)
eps = rnorm(n)
Y = 1 + X1 + X2 + eps
X = data.frame(X1 = X1, X2 = X2)
ML = c("CIF")
m = modest(X,Y,ML=ML, cf.depth = 6, mtry = 2, rf.cf.ntree = 500)
rm(list = ls())
library(devtools)
document()
set.seed(1)
n = 500
X1 = rnorm(n)
X2 = rnorm(n)
eps = rnorm(n)
Y = 1 + X1 + X2 + eps
X = data.frame(X1 = X1, X2 = X2)
ML = c("CIF")
m = modest(X,Y,ML=ML, cf.depth = 2, mtry = 2, rf.cf.ntree = 500)
rm(list = ls())
library(devtools)
document()
set.seed(1)
n = 500
X1 = rnorm(n)
X2 = rnorm(n)
eps = rnorm(n)
Y = 1 + X1 + X2 + eps
X = data.frame(X1 = X1, X2 = X2)
ML = c("CIF")
m = modest(X,Y,ML=ML, cf.depth = 2, mtry = 2, rf.cf.ntree = 50)
mm = MLest(X,Y,ML=ML, cf.depth = 2, mtry = 2, rf.cf.ntree = 50)
mm$FVs
mcv <- MLtuning(X,Y,ML = ML, mtry = c(1,2), cf.depth.grid = c(1,2),
rf.cf.ntree.grid = c(30, 50), verbose = TRUE)
mcv$results_best
fvs = as.numeric(mcv$best.fvs.across.ml)
var(fvs)
# Load required library
library(ggplot2)
library(dplyr)
fvs0 = 1 + X1 + X2
dfpl = data.frame(fvs0 = fvs0, fvs = fvs)
# Order the data by fvs0
dfpl <- dfpl %>%
arrange(fvs0) %>%
mutate(index = row_number())
# Create the ggplot
ggplot(dfpl, aes(x = index)) +
geom_line(aes(y = fvs0, color = "fvs0"), size = 1) +
geom_line(aes(y = fvs, color = "fvs"), size = 1) +
labs(title = "Ordered Data Plot",
x = "Index",
y = "Values",
color = "Legend") +
theme_minimal()
# sign accuracy
n1 = n-1
sgnacc <- sapply(1:n1, function(uu){
uu1 <- uu + 1
aaa = (fvs[uu] > fvs[uu1:n]) - (fvs[uu] < fvs[uu1:n]) !=
(fvs0[uu] > fvs0[uu1:n]) - (fvs0[uu] < fvs0[uu1:n])
})
mean(unlist(sgnacc))
